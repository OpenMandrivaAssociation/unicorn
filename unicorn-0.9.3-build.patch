--- ./amu/bsp.h.build	2003-09-26 13:19:08.000000000 +0200
+++ ./amu/bsp.h	2007-09-28 22:12:34.000000000 +0200
@@ -18,7 +18,9 @@
 #define DMT_IN_PIN0_MASK		0x0001	// GP_IN0  bit 0
 #define DMT_IN_PIN1_MASK		0x0002	// GP_IN1  bit 1
 
+#ifdef __cplusplus
 extern "C" {
+#endif
 
 unsigned short initializeBoard(void);
 unsigned long powerUp_Modem_Chipset (unsigned long Chipset);
@@ -26,6 +28,8 @@ unsigned long powerDown_Modem_Chipset (u
 unsigned long pull_Modem_Chipset_out_of_reset(unsigned long Chipset);
 unsigned long put_Modem_Chipset_in_reset(unsigned long Chipset); 
 
+#ifdef __cplusplus
 }	// extern "C"
+#endif
 
 #endif
--- ./msw/linrapi.c.build	2007-09-28 22:11:27.000000000 +0200
+++ ./msw/linrapi.c	2007-09-28 22:13:01.000000000 +0200
@@ -201,7 +201,7 @@ __cxa_pure_virtual(void)
 	WARN("__cxa_pure_virtual called\n");
 }
 
-#if __GNUC__ >= 3
+#if __GNUC__ >= 3 && defined(__cplusplus)
 extern void
  __builtin_delete(void *ptr)
 {
--- ./unicorn_pci/Makefile.build	2007-09-28 22:11:27.000000000 +0200
+++ ./unicorn_pci/Makefile	2007-09-28 22:13:20.000000000 +0200
@@ -34,7 +34,7 @@ include $(KERNEL_SOURCES)/.config
 # -DUSE_HW_TIMER - set this to use 2ms PCI hardware timer
 # -DPCI_BRIDGE_WORKAROUND - set this to work with low performance PCI bridges
 # -DKT400 - set this if you have a MSI KT4 motherboard or similar
-COPTIONS =
+COPTIONS='-DKBUILD_MODNAME=KBUILD_STR(unicorn_pci)'
 
 # make parameters
 CC=gcc
--- ./unicorn_usb/Makefile.build	2007-09-28 22:11:27.000000000 +0200
+++ ./unicorn_usb/Makefile	2007-09-28 22:13:28.000000000 +0200
@@ -30,7 +30,7 @@ endif
 
 # OPTIONS
 #
-COPTIONS =
+COPTIONS='-DKBUILD_MODNAME=KBUILD_STR(unicorn_usb)'
 
 # make parameters
 CC=gcc
--- ./unicorn_usb/unicorn_usbdrv.c.build	2007-09-28 22:11:27.000000000 +0200
+++ ./unicorn_usb/unicorn_usbdrv.c	2007-09-28 22:13:36.000000000 +0200
@@ -120,8 +120,8 @@ static void dump_urb(struct urb *urb)
 
 	printk(KERN_DEBUG "hcpriv=%p,dev=%p,pipe=%x,status=%d,transfer_flags=%d\n",
 	       urb->hcpriv,urb->dev,urb->pipe,urb->status,urb->transfer_flags);
-	printk(KERN_DEBUG "bandwidth=%d,start_frame=%u,interval=%d,error_count=%d\n",
-	    urb->bandwidth,urb->start_frame,urb->interval,urb->error_count);
+	printk(KERN_DEBUG "start_frame=%u,interval=%d,error_count=%d\n",
+	    urb->start_frame,urb->interval,urb->error_count);
 	// buffers
 	printk(KERN_DEBUG "transfer_buffer=%p,transfer_buffer_length=%d,actual_length=%d\n",
 	       urb->transfer_buffer,urb->transfer_buffer_length,urb->actual_length);
--- /dev/null	2005-10-13 10:44:11.000000000 +0200
+++ ./amu/amas.c	2007-09-28 22:45:00.000000000 +0200
@@ -0,0 +1,160 @@
+#include "types.h"
+#include "tracetool.h"
+#include "amas.h"				/* AMAS API's and typedefs */
+#include "rapi.h"
+
+extern unsigned long	g_ModemState, g_ShowtimeCounter;
+extern unsigned int 	g_WaitForShowtime, g_WaitForInit;
+extern int				L3_flag;
+									
+extern T_AMSW_ANT_StaticConfiguration	g_StaticCfg;
+extern T_AMSW_NT_NearEndLineOperData 	g_NearEndLineOperData;
+extern T_AMSW_NT_FarEndLineOperData 	g_FarEndLineOperData;
+extern T_AMSW_def_counter_set 			g_def_counter_set;
+extern T_AMSW_def_bitmap_set 			g_def_bitmap_set;
+extern T_AMSW_def_counters				g_def_counters;
+extern T_AMSW_NT_ChannelOperData 		g_ChannelOperData;
+extern T_AMSW_ANT_CustomerConfiguration	g_CustomerCfg;
+extern T_AMSW_PowerStateConfiguration 	g_PowerStateCfg;
+extern T_AMSW_Teq						g_Teq;
+extern T_AMSW_Ber						g_Ber;
+extern T_AMSW_VersionMS					g_VersionMS;
+
+// ADSL Modem Software calls this function to report any state changes
+void AMSW_ANT_reportModemStateChange(AMSW_ModemState p_ModemState)
+{
+	g_ModemState = p_ModemState;
+
+	char *s;
+	switch(p_ModemState)
+	{
+	case C_AMSW_IDLE             : s = "IDLE";             break; 
+	case C_AMSW_L3               : s = "L3";               break; 
+	case C_AMSW_LISTENING        : s = "LISTENING";        break; 
+	case C_AMSW_ACTIVATING       : s = "ACTIVATING";       break;
+	case C_AMSW_Ghs_HANDSHAKING  : s = "Ghs_HANDSHAKING";  break; 
+	case C_AMSW_ANSI_HANDSHAKING : s = "ANSI_HANDSHAKING"; break; 
+	case C_AMSW_INITIALIZING     : s = "INITIALIZING";     break; 
+	case C_AMSW_RESTARTING       : s = "RESTARTING";       break; 
+	case C_AMSW_FAST_RETRAIN     : s = "FAST_RETRAIN";     break; 
+	case C_AMSW_SHOWTIME_L0      : s = "SHOWTIME_L0";      break; 
+	case C_AMSW_SHOWTIME_LQ      : s = "SHOWTIME_LQ";      break; 
+	case C_AMSW_SHOWTIME_L1      : s = "SHOWTIME_L1";      break; 
+	case C_AMSW_EXCHANGE         : s = "EXCHANGE";         break; 
+	case C_AMSW_TRUNCATE         : s = "TRUNCATE";         break; 
+	case C_AMSW_ESCAPE           : s = "ESCAPE";           break; 
+	default                      : s = "Unknown State";    break; 
+	}
+	PRINT_ERROR("Current Modem State (%d): %s\n", g_ModemState, s);
+
+	msw_report_event(MSW_EVENT_STATE,p_ModemState);
+}
+
+// ADSL Modem Software calls this function to report events
+void AMSW_ANT_reportEvent(AMSW_ModemEvent p_Event)
+{
+	char *s;
+	switch(p_Event)
+	{
+	default                            : s = "UNKNOWN";                break;
+	case C_AMSW_PEER_ATU_FOUND         : s = "Peer ATU Found";         break;
+	case C_AMSW_RESTART_REQUEST        : s = "Restart Request";        break;
+	case C_AMSW_ACTIVATION_REQUEST     : s = "Activation Request";     break;
+	case C_AMSW_L3_EXECUTED            : s = "L3 Executed"; 
+		g_ModemState = C_AMSW_IDLE;
+		L3_flag = TRUE;
+		break;
+	case C_AMSW_L3_REJECTED            : s = "L3 Rejected";       
+		L3_flag = TRUE;
+		break;
+	case C_AMSW_L1_EXECUTED            : s = "L1 Executed";            break;
+	case C_AMSW_L1_REJECTED            : s = "L1 Rejected";            break;
+	case C_AMSW_L0_REJECTED            : s = "L0 Rejected";            break;
+	case C_AMSW_RESTART_ACCEPTABLE     : s = "Restart Acceptable";     break;
+	case C_AMSW_RESTART_NOT_ACCEPTABLE : s = "Restart Not Acceptable"; break;
+
+	case C_AMSW_TO_INITIALIZING        : s = "Initializing";
+		g_WaitForInit = 0;
+		g_WaitForShowtime = 0;
+		break;
+
+	case C_AMSW_SHOWTIME               : s = "Showtime";
+		g_WaitForShowtime = 0;
+		g_ShowtimeCounter = 0;	
+		break;
+
+	case C_AMSW_SUICIDE_REQUEST        : s = "Suicide Request"; 
+		// orderly shutdown request from peer ATU
+		g_ModemState = C_AMSW_DISORDERLY;
+		break;
+
+	}
+	PRINT_ERROR("Event Reported (%d): %s\n", (int)p_Event, s);
+
+	msw_report_event(MSW_EVENT_REPORT,p_Event);
+}
+
+// ADSL Modem Software calls this function to report the reason for failure
+void AMSW_ANT_reportModemFailure(AMSW_ModemFailure p_FailureCause)
+{
+	char *s;
+	switch(p_FailureCause)
+	{
+	case C_AMSW_UNCOMPATIBLE_LINECONDITIONS :
+		s = "Uncompatible Line Conditions";
+		break;
+
+	case C_AMSW_NO_LOCK_POSSIBLE :
+		s = "No Lock Possible";
+		break;
+
+	case C_AMSW_PROTOCOL_ERROR :
+		s = "Protocol Error";
+		break;
+
+	case C_AMSW_MESSAGE_ERROR :
+		s = "Message Error";
+		break;
+
+	case C_AMSW_SPURIOUS_ATU_DETECTED :
+		s = "Spurious ATU Detected";
+		break;
+
+	case C_AMSW_FORCED_SILENCE :
+		s = "Forced Silence";
+		break;
+
+	case C_AMSW_DS_REQ_BITRATE_TOO_HIGH_FOR_LITE :
+		s = "Requested Bit Rate Too High";
+		break;
+
+	case C_AMSW_INTERLEAVED_PROFILE_REQUIRED_FOR_LITE :
+		s = "Interleaved Profile Required for LITE";
+		break;
+
+	case C_AMSW_UNSELECTABLE_OPERATION_MODE :
+		s = "Unselectable Operation Mode";
+		break;
+
+	case C_AMSW_STATE_REFUSED_BY_GOLDEN :
+		s = "State Refused By Golden";
+		break;
+
+	default : 
+		s = "Unknown Cause";
+		break;
+	}
+
+	// Disorderly shutdown
+	PRINT_ERROR("Modem Init Failure: %s (%d)\n", s, p_FailureCause); 
+	g_ModemState = C_AMSW_DISORDERLY;
+
+	msw_report_event(MSW_EVENT_FAILURE,p_FailureCause);
+}
+
+AMSW_ResultCode AMSW_ANT_wait_event(unsigned long *event)
+{
+  *event= last_report;
+  return 0;
+}
+
--- /dev/null	2005-10-13 10:44:11.000000000 +0200
+++ ./amu/bsp_pci.c	2007-09-28 22:45:22.000000000 +0200
@@ -0,0 +1,107 @@
+#include "types.h"
+#include "tracetool.h"
+#include "hal.h"
+#include "hard.h"
+#include "rapi.h"
+#include "bsp.h"		// AMAS API's and typedefs
+
+#ifndef _PCI_DRIVER
+#error not_PCI_DRIVER
+#endif
+
+unsigned short initializeBoard(void)
+{
+	T_SlaveMaskData p;
+	ST_STATUS status;
+
+	// TX_DSP_Register configured in ATU-R Mode
+	p.iaddr  = SACHEM_TX_DSP;
+	p.idata  = TX_DSP_MODE_ATUR;
+	p.mask   = MASK_TX_DSP_MODE;
+	p.status = 0x2823;
+	status = PCI_SlaveRMWrite(&p);
+	if (status == FAILURE) PRINT_ERROR("PCI_SlaveRMWrite() failed\n");
+
+	xtm_wkafter(1);
+
+	// AFE in Reset (UNICORN)
+	p.iaddr  = DMT_GPIO_OFFSET;
+	p.idata  = DMT_OUT_PIN_LOW;
+	p.mask   = MASK_DMT_OUT_PIN_LOW;
+	p.status = 0x2823;
+	status = PCI_SlaveRMWrite(&p);
+	if (status == FAILURE) PRINT_ERROR("PCI_SlaveRMWrite() failed\n");
+
+	xtm_wkafter(1);
+
+	// AFE in Power Down (UNICORN)
+	p.iaddr  = SACHEM_TX_DSP;
+	p.idata  = AFE_POWER_DOWN; // fisaksen
+	p.mask   = MASK_AFE_POWER_DOWN;
+	p.status = 0x2823;
+	status = PCI_SlaveRMWrite(&p);
+	if (status == FAILURE) PRINT_ERROR("PCI_SlaveRMWrite() failed\n");
+
+	xtm_wkafter(1);
+
+	// AFE out of Reset (UNICORN)
+	p.iaddr  = DMT_GPIO_OFFSET;
+	p.idata  = DMT_OUT_PIN_HIGH;
+	p.mask   = MASK_DMT_OUT_PIN_LOW;
+	p.status = 0x2823;
+	status = PCI_SlaveRMWrite(&p);
+	if (status == FAILURE) PRINT_ERROR("PCI_SlaveRMWrite() failed\n");
+
+	xtm_wkafter(1);
+
+	// AFE in PowerUp (UNICORN)
+	p.iaddr  = SACHEM_TX_DSP;
+	p.idata  = AFE_POWER_UP; // fisaksen
+	p.mask   = MASK_AFE_POWER_DOWN;
+	p.status = 0x2823;
+	status = PCI_SlaveRMWrite(&p);
+	if (status == FAILURE) PRINT_ERROR("PCI_SlaveRMWrite() failed\n");
+
+	xtm_wkafter(1);
+	return 0;
+}
+
+unsigned long powerUp_Modem_Chipset (unsigned long Chipset)
+{
+	T_SlaveMaskData p;
+	ST_STATUS status;
+
+	// AFE out of Reset (UNICORN)
+	p.iaddr  = DMT_GPIO_OFFSET;
+	p.idata  = DMT_OUT_PIN_HIGH;
+	p.mask   = MASK_DMT_OUT_PIN_LOW;
+	p.status = 0x2823;
+	status = PCI_SlaveRMWrite(&p);
+	if (status == FAILURE) PRINT_ERROR("PCI_SlaveRMWrite() failed\n");
+	xtm_wkafter(1);
+	return 0;
+}
+
+
+unsigned long powerDown_Modem_Chipset (unsigned long Chipset)
+{
+	return 0;
+}
+
+unsigned long pull_Modem_Chipset_out_of_reset(unsigned long Chipset)
+{
+	return 0;
+}
+
+unsigned long put_Modem_Chipset_in_reset(unsigned long Chipset)
+{
+	return 0;
+}
+
+void HandleAtmError(void)
+{
+}
+
+void HandleLeds(void)
+{
+}
--- /dev/null	2005-10-13 10:44:11.000000000 +0200
+++ ./amu/bsp_usb.c	2007-09-28 22:45:55.000000000 +0200
@@ -0,0 +1,152 @@
+//#define USB_KERNEL_DEBUG
+
+#include "types.h"
+#include "tracetool.h"
+#include "hal.h"
+#include "hard.h"
+#include "rapi.h"
+#include "bsp.h"		// AMAS API's and typedefs
+
+#ifndef _USB_DRIVER
+#error not_USB_DRIVER
+#endif
+
+unsigned short initializeBoard(void)
+{
+
+	ST_STATUS status;
+	unsigned short iaddr_val, idata_val, irmw_val;
+
+	// TX_DSP_Register configured in ATU-R Mode
+
+	status = USB_controlWrite(UR_IADR,SACHEM_TX_DSP);
+	if (status == FAILURE) PRINT_ERROR("USB_controlWrite() failed\n");
+	status = USB_controlWrite(UR_IDATA,TX_DSP_MODE_ATUR);
+	if (status == FAILURE) PRINT_ERROR("USB_controlWrite() failed\n");
+	status = USB_controlWrite(UR_IRMW,MASK_TX_DSP_MODE);
+	if (status == FAILURE) PRINT_ERROR("USB_controlWrite() failed\n");
+	status = USB_controlWrite(UR_STATUS,0x2823);
+	if (status == FAILURE) PRINT_ERROR("USB_controlWrite() failed\n");
+
+	PRINT_INFO("USB> TX_DSP_Register configuration DONE!\n");
+
+	// AFE in Reset
+
+	iaddr_val = DMT_GPIO_OFFSET;
+	idata_val = DMT_OUT_PIN_LOW;
+	irmw_val  = MASK_DMT_OUT_PIN_LOW;
+
+	status = USB_controlWrite(UR_IADR,iaddr_val);
+	if (status == FAILURE) PRINT_ERROR("USB_controlWrite() failed\n");
+	status = USB_controlWrite(UR_IDATA,idata_val);
+	if (status == FAILURE) PRINT_ERROR("USB_controlWrite() failed\n");
+	status = USB_controlWrite(UR_IRMW,irmw_val);
+	if (status == FAILURE) PRINT_ERROR("USB_controlWrite() failed\n");
+	status = USB_controlWrite(UR_STATUS,0x2823);
+	if (status == FAILURE) PRINT_ERROR("USB_controlWrite() failed\n");
+
+	PRINT_INFO("USB> AFE_RESET: DONE!\n");
+
+	// AFE in PowerDown
+
+	iaddr_val = SACHEM_TX_DSP;
+	idata_val = AFE_POWER_UP;
+	irmw_val  = MASK_AFE_POWER_DOWN;
+
+	status = USB_controlWrite(UR_IADR,iaddr_val);
+	if (status == FAILURE) PRINT_ERROR("USB_controlWrite() failed\n");
+	status = USB_controlWrite(UR_IDATA,idata_val);
+	if (status == FAILURE) PRINT_ERROR("USB_controlWrite() failed\n");
+	status = USB_controlWrite(UR_IRMW,irmw_val);
+	if (status == FAILURE) PRINT_ERROR("USB_controlWrite() failed\n");
+	status = USB_controlWrite(UR_STATUS,0x2823);
+	if (status == FAILURE) PRINT_ERROR("USB_controlWrite() failed\n");
+
+	PRINT_INFO("USB> AFE_POWER_DOWN: DONE!\n");
+
+	// AFE out of Reset
+
+	iaddr_val = DMT_GPIO_OFFSET;
+	idata_val = DMT_OUT_PIN_HIGH;
+	irmw_val  = MASK_DMT_OUT_PIN_LOW;
+
+	status = USB_controlWrite(UR_IADR,iaddr_val);
+	if (status == FAILURE) PRINT_ERROR("USB_controlWrite() failed\n");
+	status = USB_controlWrite(UR_IDATA,idata_val);
+	if (status == FAILURE) PRINT_ERROR("USB_controlWrite() failed\n");
+	status = USB_controlWrite(UR_IRMW,irmw_val);
+	if (status == FAILURE) PRINT_ERROR("USB_controlWrite() failed\n");
+	status = USB_controlWrite(UR_STATUS,0x2823);
+	if (status == FAILURE) PRINT_ERROR("USB_controlWrite() failed\n");
+
+	PRINT_INFO("USB> AFE_OUT_OF_RESET: DONE!\n");
+
+		// AFE Power Up
+
+	iaddr_val = SACHEM_TX_DSP;
+	idata_val = AFE_POWER_DOWN;
+	irmw_val  = MASK_AFE_POWER_DOWN;
+
+	status = USB_controlWrite(UR_IADR,iaddr_val);
+	if (status == FAILURE) PRINT_ERROR("USB_controlWrite() failed\n");
+	status = USB_controlWrite(UR_IDATA,idata_val);
+	if (status == FAILURE) PRINT_ERROR("USB_controlWrite() failed\n");
+	status = USB_controlWrite(UR_IRMW,irmw_val);
+	if (status == FAILURE) PRINT_ERROR("USB_controlWrite() failed\n");
+	status = USB_controlWrite(UR_STATUS,0x2823);
+	if (status == FAILURE) PRINT_ERROR("USB_controlWrite() failed\n");
+
+	PRINT_INFO("USB> AFE_POWER_UP: DONE!\n");
+
+#ifdef USB_KERNEL_DEBUG
+  if ( (status = USB_controlWrite(0x61,0x00)) == FAILURE )
+			PRINT_ERROR("Configuration of GPIO_DIR register failed!\n");
+
+	PRINT_INFO("USB> GPIO_DIR: INITIALIZED!\n");
+#endif
+
+	return 0;
+}
+
+unsigned long powerUp_Modem_Chipset (unsigned long Chipset)
+{
+	ST_STATUS				status;
+	unsigned short  iaddr_val, idata_val, irmw_val;
+
+	iaddr_val = DMT_GPIO_OFFSET;
+	idata_val = DMT_OUT_PIN_HIGH;
+	irmw_val	= MASK_DMT_OUT_PIN_LOW;
+
+	status = USB_controlWrite(UR_IADR,iaddr_val);
+	if (status == FAILURE) PRINT_ERROR("USB_controlWrite() failed\n");
+
+	status = USB_controlWrite(UR_IDATA,idata_val);
+	if (status == FAILURE) PRINT_ERROR("USB_controlWrite() failed\n");
+
+	status = USB_controlWrite(UR_IRMW,irmw_val);
+	if (status == FAILURE) PRINT_ERROR("USB_controlWrite() failed\n");
+
+	status = USB_controlWrite(UR_STATUS,0x2823);
+	if (status == FAILURE) PRINT_ERROR("USB_controlWrite() failed\n");
+
+	PRINT_INFO("USB powerUp_Modem_Chipset completed\n");
+
+	return 0;
+}
+
+
+unsigned long powerDown_Modem_Chipset (unsigned long Chipset)
+{
+	return 0;
+}
+
+unsigned long pull_Modem_Chipset_out_of_reset(unsigned long Chipset)
+{
+	return 0;
+}
+
+unsigned long put_Modem_Chipset_in_reset(unsigned long Chipset)
+{
+	return 0;
+}
+
--- /dev/null	2005-10-13 10:44:11.000000000 +0200
+++ ./amu/amu.c	2007-09-28 22:52:15.000000000 +0200
@@ -0,0 +1,517 @@
+#include "types.h"
+#include "tracetool.h"
+#include "rapi.h"  
+#include "hard.h"
+#include "hal.h"
+#include "amas.h"
+#include "amu.h"
+#define _PICAP_CODE_
+#ifdef _PICAP_CODE_
+extern long Vendor_Id_code_ECI;
+#endif
+
+
+
+//#define PM_FM_POLLING_RATE          1000// milliseconds
+//#define INIT_POLLING_TIME           2    // (INIT_POLLING_TIME* PM_FM_POLLING_RATE) milliseconds
+//#define WAITFOR_SHOWTIME_COUNT      20   // (WAITFOR_SHOWTIME_COUNT * PM_FM_POLLING_RATE) millisecs 
+#define RETRY_WAIT_TIME_MIN_MSEC      5000 // 5 seconds (between line disable and reenable)
+
+//#define WAITFOR_DISORDERLY_COUNT    2000   // (WAITFOR_DISORDERLY_COUNT * PM_FM_POLLING_RATE) msecs 
+
+//#define NEAR_LCDNI_COUNT            15  // 15 seconds timeout of near end LCD persistency
+//#define NEAR_LCDI_COUNT             15  // 15 seconds timeout of near end LCDI persistency
+//#define NEAR_LOS_COUNT              5   // 5 seconds timeout of near end LOS persistency
+//#define NEAR_LOF_COUNT              5   // 5 seconds timeout of near end LOF persistency
+//#define FAR_LCDNI_COUNT             17  // 17 seconds timeout of far end LCD persistency
+//#define FAR_LCDI_COUNT							17  // 17 seconds timeout of far end LCD persistency
+//#define FAR_LOS_COUNT               5   // 6 seconds timeout of far end LOS persistency
+//#define FAR_LOF_COUNT               5   // 6 seconds timeout of far end LOF persistency
+//#define FAR_LOS_SHORT_COUNT         4   // 4 seconds timeout of far end LOS persistency
+//#define FAR_LOF_SHORT_COUNT         4   // 4 seconds timeout of far end LOF persistency
+
+
+//#define CRC_FAST_COUNT              5   // (CRC_FAST_COUNT * AMUTASK_MSG_WAIT_TIME) millisecs
+//#define CRC_INTERLEAVED_COUNT       5   // (CRC_INTERLEAVED_COUNT * AMUTASK_MSG_WAIT_TIME) milli
+//#define WATCHDOG_COUNTER_VALUE      500	// Time to reset = (WATCHDOG_COUNTER_VALUE * 2) * 8.192 
+																					// milli sec
+
+unsigned long NEAR_LCDNI_COUNT;         
+unsigned long NEAR_LCDI_COUNT;          
+unsigned long NEAR_LOS_COUNT;           
+unsigned long NEAR_LOF_COUNT;           
+unsigned long FAR_LCDNI_COUNT;          
+unsigned long FAR_LCDI_COUNT;						
+unsigned long FAR_LOS_COUNT;            
+unsigned long FAR_LOF_COUNT;            
+unsigned long FAR_LOS_SHORT_COUNT;      
+unsigned long FAR_LOF_SHORT_COUNT;      
+
+#if 0
+//ModemSW variables
+extern T_AMSW_Identification                g_Identification;
+extern T_AMSW_NT_NearEndLineOperData        g_NearEndLineOperData;
+extern T_AMSW_NT_FarEndLineOperData         g_FarEndLineOperData;
+extern T_AMSW_def_counter_set               g_def_counter_set;
+extern T_AMSW_def_bitmap_set                g_def_bitmap_set;
+extern T_AMSW_def_counters                  g_def_counters;
+extern T_AMSW_NT_ChannelOperData            g_ChannelOperData;
+extern T_AMSW_ANT_CustomerConfiguration     g_CustomerCfg;
+extern T_AMSW_ANT_StaticConfiguration       g_StaticCfg;
+extern T_AMSW_PowerStateConfiguration       g_PowerStateCfg;   
+extern T_AMSW_Teq g_Teq; //STM G
+extern T_AMSW_Ber g_Ber;
+extern T_AMSW_VersionMS g_VersionMS;
+#endif
+
+extern unsigned long DownstreamRate;	// In Kbits/sec	
+unsigned long FmPollingRate = 1000;
+unsigned long InitTimeout = 20000;
+//unsigned long ActTimeout = 10000;
+unsigned long ActTimeout = 300000;	// Fix for Alcatel 4.2.13
+unsigned long RetryTime = 5000;
+
+unsigned long LCD_Trig = 15000;
+unsigned long LOS_LOF_Trig = 5000;
+
+extern unsigned long Vendor_Id_code_Globspan;
+unsigned long Vendor_Id_code_Globspan=0;
+
+void HandleAtmError(void);
+void HandleLeds(void);
+	
+unsigned long amu_init_modem(unsigned short MODE);
+unsigned long amu_init_modem(unsigned short MODE)
+{
+	unsigned long l_RetCode;
+
+	//
+	// Static Configuration
+	//
+	g_StaticCfg.utopiaMode = C_AMSW_UTOPIA_LEVEL1;
+	g_StaticCfg.utopiaFast = 0;
+	g_StaticCfg.utopiaSlow = 0;
+	for (l_RetCode=0; l_RetCode<32; l_RetCode++)
+		g_StaticCfg.serialNumber[l_RetCode] = '9';
+//	g_StaticCfg.maximumDownstreamLineRate = 5000;				
+	g_StaticCfg.maximumDownstreamLineRate = DownstreamRate;
+	g_StaticCfg.managementVersion = 1;
+	g_StaticCfg.goldenMode = AMSW_GOLDEN_OFF;
+	g_StaticCfg.vendorIdentif.countryCode = 0x0f;
+	g_StaticCfg.vendorIdentif.reserved = 0x00;
+	g_StaticCfg.vendorIdentif.vendorCode = (0x41 << 24) | (0x4c << 16) | (0x43 << 8) | (0x42); /*"ALCB"*/ //RFC016
+//	g_StaticCfg.vendorIdentif.vendorCode = 0x3A; //STMicroelectronics
+	g_StaticCfg.vendorIdentif.vendorSpecific = 0x0451;
+
+	//
+	//	Customer Configuration
+	//
+
+	switch(MODE)
+	{
+	case MSW_MODE_ANSI:
+		g_CustomerCfg.POTSoverlayOperationModes = AMSW_ANSI;
+		break;
+	case MSW_MODE_GLITE:
+		g_CustomerCfg.POTSoverlayOperationModes = AMSW_G_LITE;
+		break;
+	case MSW_MODE_GDMT:
+		g_CustomerCfg.POTSoverlayOperationModes = AMSW_G_DMT;
+		break;		
+	case MSW_MODE_MULTI:	default:
+		g_CustomerCfg.POTSoverlayOperationModes = AMSW_G_DMT | AMSW_ANSI | AMSW_G_LITE;
+		break;
+	}
+
+	g_CustomerCfg.POTSoverlayPermissions[0] = AMSW_TRELLIS | AMSW_BITSWAP;   // ANSI
+	
+#ifdef SUICIDE_FIX	
+	g_CustomerCfg.POTSoverlayPermissions[1] = AMSW_TRELLIS | AMSW_DS_PILOT_MODULATED | AMSW_POWER_MANAGEMENT;	    //DMT
+#else
+	g_CustomerCfg.POTSoverlayPermissions[1] = AMSW_TRELLIS | AMSW_DS_PILOT_MODULATED;							// DMT													
+#endif
+														
+	g_CustomerCfg.POTSoverlayPermissions[2] = AMSW_LQ;																														// UAWG
+	g_CustomerCfg.POTSoverlayPermissions[3] = AMSW_BITSWAP | AMSW_RS16 | AMSW_TRELLIS | AMSW_DS_PILOT_MODULATED ;	// G.LITE
+	g_CustomerCfg.POTSoverlayPermissions[4] = 0;
+	g_CustomerCfg.POTSoverlayPermissions[5] = 0;
+	g_CustomerCfg.POTSoverlayPermissions[6] = 0;
+	g_CustomerCfg.POTSoverlayPermissions[7] = 0;
+	
+	//
+	// ISDN
+	//
+	g_CustomerCfg.ISDNoverlayOperationModes = 0;
+	for (l_RetCode = 0; l_RetCode < 8; l_RetCode++)
+		g_CustomerCfg.ISDNoverlayPermissions[l_RetCode] = 0;
+	for (l_RetCode = 0; l_RetCode < 8; l_RetCode++)
+		g_CustomerCfg.ISDNoverlayPermissions[l_RetCode] = 0;
+		
+	//
+	// Power State Configuration
+	//
+	g_PowerStateCfg.powerStateControl = AMSW_L3 | AMSW_L1;
+
+	// Setup modem configuration
+	l_RetCode = AMSW_ANT_setModemConfiguration(C_AMSW_STATIC_CONFIGURATION,&g_StaticCfg);
+	if (l_RetCode != C_AMSW_ACK)
+		PRINT_ERROR("Error in AMSW_ANT_setModemConfiguration-1 (%d)\n", l_RetCode);
+	l_RetCode = AMSW_ANT_setModemConfiguration(C_AMSW_CUSTOMER_CONFIGURATION,&g_CustomerCfg);
+	if (l_RetCode != C_AMSW_ACK)
+		PRINT_ERROR("Error in AMSW_ANT_setModemConfiguration-2 (%d)\n", l_RetCode);
+	l_RetCode = AMSW_ANT_setModemConfiguration(C_AMSW_POWER_STATE_CONTROL,&g_PowerStateCfg);
+	if (l_RetCode != C_AMSW_ACK)
+		PRINT_ERROR("Error in AMSW_ANT_setModemConfiguration-3 (%d)\n", l_RetCode);
+	return l_RetCode;
+}
+
+void AMUTask(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
+{
+	unsigned long   l_RetCode = C_AMSW_REJ;
+	//static int      l_Lit = 0;
+	static int     PM_toggle = TRUE;
+
+	PRINT_ERROR("FmPollingRate=%ldms,InitTimeout=%ldms,ActTimeout=%ld\n",
+		   FmPollingRate,InitTimeout,ActTimeout);
+
+	unsigned long PM_FM_POLLING_RATE = FmPollingRate;
+	unsigned long WAITFOR_SHOWTIME_COUNT = InitTimeout / PM_FM_POLLING_RATE;
+	unsigned long WAITFOR_INIT_COUNT = ActTimeout / PM_FM_POLLING_RATE;
+	unsigned long RETRY_WAIT_TIME = RETRY_WAIT_TIME_MIN_MSEC / PM_FM_POLLING_RATE;
+	if (RetryTime > RETRY_WAIT_TIME_MIN_MSEC)	// STM Gian Set RetryTime Only if is Bigger then minimum value
+		RETRY_WAIT_TIME = RetryTime / PM_FM_POLLING_RATE;
+	unsigned long INIT_POLLING_TIME = 5; //(??????) 
+	unsigned long WAITFOR_DISORDERLY_COUNT = 3; 
+
+	NEAR_LCDNI_COUNT = LCD_Trig / PM_FM_POLLING_RATE;         
+	NEAR_LCDI_COUNT = NEAR_LCDNI_COUNT;          
+	NEAR_LOS_COUNT = LOS_LOF_Trig / PM_FM_POLLING_RATE;           
+	NEAR_LOF_COUNT = NEAR_LOS_COUNT;           
+	FAR_LCDNI_COUNT = NEAR_LCDNI_COUNT;          
+	FAR_LCDI_COUNT = NEAR_LCDNI_COUNT;						
+	FAR_LOS_COUNT = NEAR_LOS_COUNT;            
+	FAR_LOF_COUNT = NEAR_LOS_COUNT;            
+	FAR_LOS_SHORT_COUNT = NEAR_LOS_COUNT;      
+	FAR_LOF_SHORT_COUNT = NEAR_LOS_COUNT;      
+
+	UINT delay = 0;
+		
+	while (amu_go)
+	{
+		xtm_wkafter(500);
+		delay += 500;
+           
+		
+		// Exit immediately on surprise removal
+		// ------------------------------------
+		if (GlobalRemove) return;
+
+		HandleAtmError();
+		HandleLeds();
+		
+		// Modem Software polling
+		// ----------------------
+		if (delay < PM_FM_POLLING_RATE) continue;
+		delay = 0;
+           
+		// Modem Software polling
+		// ----------------------
+		switch(g_ModemState)
+		{
+		case C_AMSW_IDLE       : 
+			g_WaitForRetry = 0; // STM Gian clear
+			g_WaitForInit = 0;  // STM Gian clear
+
+			break;
+		case C_AMSW_ACTIVATING : 
+			g_WaitForInit++;
+			if(g_WaitForInit >= WAITFOR_INIT_COUNT)
+			{
+				msw_report_event(AMU_EVENT_ACT_TIMEOUT,0);
+				PRINT_ERROR("Timeout in activation!!!!\n");
+				g_ModemState = C_AMSW_DISORDERLY;
+				g_WaitForInit = 0;
+			}
+			break;
+		case C_AMSW_L3         : break;
+		case C_AMSW_SHOWTIME_L0:
+		case C_AMSW_SHOWTIME_LQ:
+		case C_AMSW_SHOWTIME_L1:
+			// Poll line for defects and performance
+			g_ShowtimeCounter++;
+			if (g_ShowtimeCounter >= INIT_POLLING_TIME)
+			{
+//				PRINT_ERROR("Polling Defects after %d ms\n", g_ShowtimeCounter*PM_FM_POLLING_RATE);
+				if ( (FM_Polling(PM_toggle) != C_AMSW_ACK ))
+				{
+					PRINT_ERROR("Error in AMSW_get_Data during Fm Polling....\n");
+					PRINT_ERROR("Fm Polling will be stopped for %d sec!!!\n",(INIT_POLLING_TIME*PM_FM_POLLING_RATE)/1000);
+					g_ShowtimeCounter = 0;
+				}
+				else
+					PM_toggle = !PM_toggle;
+			}
+			break;
+		case C_AMSW_INITIALIZING :
+		case C_AMSW_Ghs_HANDSHAKING :
+		case C_AMSW_ANSI_HANDSHAKING :
+
+			// WAIT to reach SHOWTIME
+			g_WaitForShowtime++;
+			if(g_WaitForShowtime >= WAITFOR_SHOWTIME_COUNT)
+			{
+				msw_report_event(AMU_EVENT_INI_TIMEOUT,0);
+				PRINT_ERROR("Timeout in initialization!!!!\n");
+				// Reset count
+				g_WaitForShowtime = 0;
+				// Disorderly shutdown 
+				g_ModemState = C_AMSW_DISORDERLY;
+			}
+			break;
+
+		case C_AMSW_DISORDERLY :
+
+			// Special state for disorderly shutdown
+			// Wait out the period of heavy burst of interrupts
+			// from CO side when line length is changed while in
+			// showtime
+		
+			g_WaitForDisorderly++;
+			if(g_WaitForDisorderly >= WAITFOR_DISORDERLY_COUNT)
+			{
+				int i;
+
+//				if (RetryTime != 0)
+//						msw_report_event(AMU_EVENT_RETRY,0);
+
+				board_disable_intrs();
+
+//				xtm_wkafter(WAITFOR_DISORDERLY_COUNT);
+
+				
+				g_ShowtimeCounter = 0;							
+				g_WaitForDisorderly = 0;
+
+				// Disorderly shutdown 
+				l_RetCode = AMSW_ANT_requestModemStateChange(C_AMSW_IDLE);
+				if(l_RetCode != C_AMSW_ACK) {
+					PRINT_ERROR("Error in AMSW_ANT_requestModemStateChange(C_AMSW_IDLE) = %d\n", l_RetCode);
+				}
+				else for (i=0; i<6; i++)
+				{
+					if (g_ModemState == C_AMSW_IDLE || GlobalRemove) break;
+					xtm_wkafter(500);
+				}
+				if (RetryTime != 0)
+				{
+					g_ModemState = C_AMSW_RETRY;
+					g_WaitForRetry = 0;
+				}
+        
+			}
+			break;
+			
+		case C_AMSW_RETRY:
+			if (RetryTime != 0)
+			{
+				g_WaitForRetry++;
+				//xtm_wkafter(RETRY_WAIT_TIME);
+#ifdef _PICAP_CODE_
+				if(Vendor_Id_code_ECI==TRUE)
+					xtm_wkafter(1000);  //modif PICAP ECI CK
+#endif
+				if (g_WaitForRetry >= RETRY_WAIT_TIME)
+                {
+					msw_report_event(AMU_EVENT_RETRY,0);
+					g_WaitForRetry = 0;
+					msw_start();
+				}
+			}
+			else
+			{
+				PRINT_ERROR("Error in AMUTask (C_AMSW_RETRY) with RetryTime != 0 (%ld)\n",RetryTime);
+				g_ModemState = C_AMSW_IDLE;
+			}
+			break;
+		default:
+			PRINT_ERROR("Error in AMUTask g_ModemState =%d not catched\n",g_ModemState);
+			g_ModemState = C_AMSW_IDLE;
+	        break;
+		}						//end switch
+	}
+}
+
+// This function  monitors the line for LOS (Loss Of Signal), LOF (Loss Of Frame),
+// LCDI (Loss Of Cell Delineation Interleaved), 
+// LCDNI (Loss Of Cell Delineation Fast)defects
+
+unsigned long FM_Polling(int pm_poll)
+{
+	unsigned long l_RetCode = C_AMSW_REJ;
+
+	if ((g_ModemState == C_AMSW_SHOWTIME_L0) ||
+			(g_ModemState == C_AMSW_SHOWTIME_LQ) ||
+			(g_ModemState == C_AMSW_SHOWTIME_L1))
+	{
+		// Get defect bit map
+		l_RetCode = AMSW_ANT_getData(C_AMSW_FM_DATA, &g_def_bitmap_set);
+		
+		if(l_RetCode == C_AMSW_ACK)
+		{
+//#######################  Loss Of Signal  ##############################   
+	
+			if( ((g_def_bitmap_set.near_end.status & LOS) == LOS) ||
+				((g_def_bitmap_set.near_end.status & LOS) == 0) && 
+				((g_def_bitmap_set.near_end.change & LOS) == LOS) )
+			{
+				g_NEAR_LOS++;
+			}
+			else
+			{
+				g_NEAR_LOS = 0;
+			}
+			if( ((g_def_bitmap_set.far_end.status & LOS) == LOS) ||
+				((g_def_bitmap_set.far_end.status & LOS) == 0) && 
+				((g_def_bitmap_set.far_end.change & LOS) == LOS) )
+			{
+				g_FAR_LOS++;
+			}
+			else
+			{
+				g_FAR_LOS = 0;
+			}
+
+//######################  Loss Of Cell Delineation Fast  ######################	
+
+			if((g_def_bitmap_set.near_end.status & LCDNI) == LCDNI)
+			{
+				g_NEAR_LCDNI++;
+			}
+			else
+			{
+				g_NEAR_LCDNI = 0;
+			}
+			if((g_def_bitmap_set.far_end.status & LCDNI) == LCDNI)
+			{
+				g_FAR_LCDNI++;
+			}
+			else
+			{
+				g_FAR_LCDNI = 0;
+			}
+
+//######################  Loss Of Cell Delineation Interleaved ######################
+
+			if((g_def_bitmap_set.near_end.status & LCDI) == LCDI)
+			{
+				g_NEAR_LCDI++;
+			}
+			else
+			{
+				g_NEAR_LCDI = 0;
+			}
+			if((g_def_bitmap_set.far_end.status & LCDI) == LCDI)
+			{
+				g_FAR_LCDI++;
+			}
+			else
+			{
+				g_FAR_LCDI = 0;
+			}
+
+		// WAIT : If over a period of time defect persists, do a disorderly shutdown
+
+			if( (g_NEAR_LOS >= NEAR_LOS_COUNT) || (g_NEAR_LCDNI >= NEAR_LCDNI_COUNT) ||
+				(g_NEAR_LCDI >= NEAR_LCDI_COUNT) )
+			{
+				g_FAR_LOS = 0;
+				g_FAR_LCDNI = 0;
+				g_FAR_LCDI = 0;
+				g_ModemState = C_AMSW_DISORDERLY;
+			}
+			else if ( (g_FAR_LOS >= FAR_LOS_COUNT) || (g_FAR_LCDNI >= FAR_LCDNI_COUNT) ||
+					(g_FAR_LCDI >= FAR_LCDI_COUNT) ||
+					((g_FAR_LOS >= FAR_LOS_SHORT_COUNT) && g_NEAR_LOS ) )
+				g_ModemState = C_AMSW_DISORDERLY;
+								
+			if(g_ModemState == C_AMSW_DISORDERLY)
+			{
+
+				PRINT_ERROR("Bringing down line due to persistent:\n");
+				PRINT_ERROR("NEAR_LOS = %d/NEAR_LCD = %d/NEAR_LCDI = %d\nFAR_LOS = %d  FAR_LCDI = %d  FAR_LCDNI = %d\n",
+					g_NEAR_LOS,  g_NEAR_LCDNI, g_NEAR_LCDI,g_FAR_LOS, g_FAR_LCDNI, g_FAR_LCDI);
+				
+				msw_report_event(AMU_EVENT_SHUTDOWN,0);
+	/*			
+				if (RetryTime != 0)
+				{
+					msw_report_event(AMU_EVENT_RETRY,0);
+					PRINT_ERROR("Auto-Retry will take place\n");
+				}
+	*/			
+
+				g_NEAR_LOS = 0; g_NEAR_LCDNI = 0; g_NEAR_LCDI = 0;
+				g_FAR_LOS = 0; g_FAR_LCDNI = 0; g_FAR_LCDI = 0;
+			}
+		/*		
+			if (pm_poll)
+			{
+				PM_Polling();
+			}
+		*/
+		}
+	}
+
+	return l_RetCode;
+}
+
+unsigned long PM_Polling(void)
+{
+   
+	  unsigned long l_RetCode = C_AMSW_REJ;
+
+		if   ((g_ModemState == C_AMSW_SHOWTIME_L0) ||
+          (g_ModemState == C_AMSW_SHOWTIME_LQ) ||
+					(g_ModemState == C_AMSW_SHOWTIME_L1)
+         )
+    {
+
+				l_RetCode = AMSW_ANT_getData(C_AMSW_PM_DATA, &g_def_counter_set);
+				if(l_RetCode != C_AMSW_ACK)
+				{
+						PRINT_ERROR("AMSW_ANT_getData error\n");
+				}
+				else
+				{
+						PRINT_INFO("\nFast Path Performance Counters:\n\n");	
+
+						PRINT_INFO("Near-end Fec-F = %5u\n", g_def_counter_set.near_end.FecNotInterleaved);
+						PRINT_INFO("Far-end Fec-F  = %5u\n", g_def_counter_set.far_end.FecNotInterleaved);
+						
+						PRINT_INFO("Near-end Crc-F = %5u\n", g_def_counter_set.near_end.CrcNotInterleaved);
+						PRINT_INFO("Far-end Crc-F  = %5u\n", g_def_counter_set.far_end.CrcNotInterleaved);
+
+						PRINT_INFO("Near-end Hec-F = %5u\n", g_def_counter_set.near_end.HecNotInterleaved);
+						PRINT_INFO("Far-end Hec-F  = %5u\n", g_def_counter_set.far_end.HecNotInterleaved);
+						
+						PRINT_INFO("Near-end Total Cell-F  = %5u\n", g_def_counter_set.near_end.TotalCellCountNotInterleaved);								
+						PRINT_INFO("Near-end Active Cell-F = %5u\n", g_def_counter_set.near_end.ActiveCellCountNotInterleaved);
+						
+						PRINT_INFO("\nInterleave Path Performance Counters:\n\n");	
+
+						PRINT_INFO("Near-end Fec-I = %5u\n", g_def_counter_set.near_end.FecInterleaved);
+						PRINT_INFO("Far-end Fec-I  = %5u\n", g_def_counter_set.far_end.FecInterleaved);
+												
+						PRINT_INFO("Near-end Crc-I = %5u\n", g_def_counter_set.near_end.CrcInterleaved);
+						PRINT_INFO("Far-end Crc-I  = %5u\n", g_def_counter_set.far_end.CrcInterleaved);
+						
+						PRINT_INFO("Near-end Hec-I = %5u\n", g_def_counter_set.near_end.HecInterleaved);
+						PRINT_INFO("Far-end Hec-I  = %5u\n", g_def_counter_set.far_end.HecInterleaved);
+						
+						PRINT_INFO("Near-end Total Cell-I  = %5u\n", g_def_counter_set.near_end.TotalCellCountInterleaved);
+						PRINT_INFO("Near-end Active Cell-I = %5u\n", g_def_counter_set.near_end.ActiveCellCountInterleaved);
+				}
+		}
+
+		return l_RetCode;
+}
--- /dev/null	2005-10-13 10:44:11.000000000 +0200
+++ ./msw/msw.c	2007-09-28 23:13:58.000000000 +0200
@@ -0,0 +1,249 @@
+//----------------------------------------------------------------------
+// Test driver for the ST Microelectronics ADSL Chip Taurus PCI/USB
+//----------------------------------------------------------------------
+// file: msw.cpp
+// Authors: Maddalena Brattoli, Christophe Piel
+// Copyright STMicroelectronics 2000
+// Copyright F.H.L.P. 2000
+//----------------------------------------------------------------------
+//#include <string.h>
+#include "types.h"
+#include "tracetool.h"
+#include "hal.h"
+#include "rapi.h"
+
+#include "../amu/amas.h"
+#include "../amu/bsp.h"
+
+int amu_go;
+
+unsigned long amu_init_modem(unsigned short MODE);
+void  AMUTask(unsigned long,unsigned long ,unsigned long ,unsigned long);
+  
+extern unsigned long g_AMUQid;
+extern unsigned long g_ModemState;
+extern unsigned int  g_WaitForInit;
+extern unsigned int  g_WaitForShowtime;
+extern int          L3_flag;
+extern unsigned long GlobalRemove;
+
+#if 0
+extern void *operator new(size_t size)
+{
+  void *ptr;
+
+  if (xm_getmem(size,&ptr) == SUCCESS) {
+  	//PRINT_INFO("new: size=%d,ptr=%p\n",size,ptr);
+  } else {
+  	ptr = NULL;
+  	PRINT_ERROR("### xm_getmem failed,size=%ld\n",size);
+  }
+  return ptr;
+}
+
+extern void *operator new[](size_t size)
+{
+  void *ptr;
+
+  if (xm_getmem(size,&ptr) == SUCCESS) {
+  	//PRINT_INFO("new[]: size=%d,ptr=%p\n",size,ptr);
+  } else {
+  	ptr = NULL;
+  	PRINT_ERROR("### xm_getmem failed,size=%ld\n",size);
+  }
+  return ptr;
+}
+
+extern void operator delete(void *ptr)
+{
+  //PRINT_INFO("delete: ptr=%p\n",ptr);
+  xm_retmem(ptr);
+}
+
+extern void operator delete[](void *ptr)
+{
+  //PRINT_INFO("delete[]: ptr=%p\n",ptr);
+  xm_retmem(ptr);
+}
+#endif
+
+void msw_init(unsigned short MODE)
+{
+	int err = 0;
+	unsigned long l_Tid;
+	unsigned long l_RetCode;
+	unsigned long l_TaskArgs[4];
+
+	err = AMSW_Modem_SW_Init(0,0,1);
+	if(err) PRINT_ERROR("AMSW_Modem_SW_Init() error\n");
+
+	err = AMSW_Chip_Halt();
+	if(err) PRINT_ERROR("AMSW_Chip_Halt() error\n");
+
+	err = initializeBoard();
+	if(err) PRINT_ERROR("initializeBoard() error\n");
+
+	err = amu_init_modem(MODE);
+ 	if(err) PRINT_ERROR("amu_init_modem error\n");
+
+	l_RetCode = xq_create((char *)"AMUQ", 0, 0, &l_TaskArgs[0]);
+	if (l_RetCode != 0)
+	{
+		PRINT_ERROR("***** AMU Queue creation error *****\n");
+	}
+	g_AMUQid = l_TaskArgs[0];
+
+	// create the AMU task
+
+	l_RetCode = xt_create((char *)"AMU0", 2, 1024, 0, 0, &l_Tid);
+	if (l_RetCode != 0)
+	{
+		PRINT_ERROR("***** AMU task creation error *****\n");
+	}
+
+	// start the AMU Task
+	amu_go = TRUE;
+	l_RetCode = xt_start(l_Tid, 0, AMUTask, l_TaskArgs);
+	if (l_RetCode != 0)
+	{
+		PRINT_ERROR("***** AMU task start error *****\n");
+	}
+}
+
+void msw_start(void)
+{
+	unsigned long 	l_RetCode = C_AMSW_REJ;
+	AMSW_ModemState l_modemState;
+
+	l_RetCode = AMSW_ANT_getModemState(&l_modemState);
+	if(l_RetCode != C_AMSW_ACK)
+	{
+		PRINT_ERROR("AMSW_ANT_getModemState error %d!\n",l_RetCode);
+	}
+	else switch(l_modemState)
+	{
+		case C_AMSW_SHOWTIME_L0 :
+		case C_AMSW_SHOWTIME_LQ :
+		case C_AMSW_SHOWTIME_L1 :
+			PRINT_ERROR("ATU_R already in SHOWTIME\n");
+			break;
+		case C_AMSW_ACTIVATING  :
+		case C_AMSW_INITIALIZING:
+//			AMSW_ANT_requestModemStateChange(C_AMSW_IDLE);
+			break;
+		case C_AMSW_L3          :
+		case C_AMSW_IDLE        :
+			l_RetCode = AMSW_ANT_requestModemStateChange(C_AMSW_ACTIVATING);
+			if(l_RetCode != C_AMSW_ACK)
+				PRINT_ERROR("AMSW_ANT_requestModemStateChange error!\n");
+			else
+			{
+				// Reset counters
+				g_WaitForInit = 0;
+				g_WaitForShowtime = 0;
+			}
+			break;
+
+		default:
+			break;
+	}
+}
+
+void msw_stop(void)
+{
+	unsigned long 	l_RetCode = C_AMSW_REJ;
+	AMSW_ModemState l_modemState;
+
+        PRINT_INFO("msw_stop\n");
+
+        if (GlobalRemove) return;
+      
+	l_RetCode = AMSW_ANT_getModemState(&l_modemState);
+	PRINT_INFO("l_modemState=%d\n",l_modemState);	
+	if (l_RetCode != C_AMSW_ACK)
+	{
+            PRINT_ERROR("AMSW_ANT_getModemState error\n");
+	}
+	else switch(l_modemState)
+	{
+		case C_AMSW_L3 :
+		case C_AMSW_IDLE :
+			PRINT_ERROR("ATU_R is DOWN\n");
+			break;
+		case C_AMSW_SHOWTIME_L0 :
+		case C_AMSW_SHOWTIME_L1 :
+		case C_AMSW_SHOWTIME_LQ :
+
+			// Perform orderly shutdown
+			l_RetCode = AMSW_ANT_requestModemStateChange(C_AMSW_L3);
+			if(l_RetCode != C_AMSW_ACK)
+			{
+				// If Error Give Disorderly shutdown
+				PRINT_ERROR("AMSW_ANT_requestModemStateChange(C_AMSW_L3) error!\n");
+				l_RetCode = AMSW_ANT_requestModemStateChange(C_AMSW_IDLE);
+				if(l_RetCode != C_AMSW_ACK)
+					PRINT_ERROR("AMSW_ANT_requestModemStateChange(C_AMSW_IDLE) error!\n");
+			}
+			else
+			{
+                            int i;
+			    PRINT_ERROR("Waiting 5 sec to verify L3_executed\n");
+                            for (i=0; i<10; i++)
+                            {
+                                // Abort everything on surprise removal
+                                if (GlobalRemove) return;
+                                				// verify acceptance of orderly shutdown
+                                if ((
+                                     g_ModemState != C_AMSW_SHOWTIME_L0 &&
+                                     g_ModemState != C_AMSW_SHOWTIME_L1 &&
+                                     g_ModemState != C_AMSW_SHOWTIME_LQ
+                                     )) break;
+                                xtm_wkafter(500);
+                            }
+                            if ((
+                                 g_ModemState == C_AMSW_SHOWTIME_L0 ||
+                                 g_ModemState == C_AMSW_SHOWTIME_L1 ||
+                                 g_ModemState == C_AMSW_SHOWTIME_LQ
+                                 ))
+                            {
+                                if (L3_flag == FALSE) // no answer received within 1 sec
+                                    PRINT_ERROR("No answer to orderly shutdown request for 1 sec!!\n");
+                                				PRINT_ERROR("Performing disorderly shutdown!!!\n");
+                                                                l_RetCode = AMSW_ANT_requestModemStateChange(C_AMSW_IDLE);
+                                                                if(l_RetCode != C_AMSW_ACK)
+                                                                    PRINT_ERROR("AMSW_ANT_requestModemStateChange(C_AMSW_IDLE) error!\n", l_RetCode);
+                            }
+                        }
+                            break;
+
+			default: 			// IDLE request FIX : 15/01/2001
+			  PRINT_ERROR("Performing disorderly shutdown!!!\n");
+				l_RetCode = AMSW_ANT_requestModemStateChange(C_AMSW_IDLE);
+				if(l_RetCode != C_AMSW_ACK)
+					PRINT_ERROR("AMSW_ANT_requestModemStateChange(C_AMSW_IDLE) error!\n");
+
+			break;
+ 	}
+}
+
+void msw_exit(void)
+{
+
+	unsigned long 	l_RetCode = C_AMSW_REJ;
+	amu_go = FALSE;
+
+        PRINT_INFO("msw_exit\n");
+
+	if (!GlobalRemove)
+        {
+            board_disable_intrs();		// disable interrupts before disabling the driver
+
+            l_RetCode = AMSW_ANT_requestModemStateChange(C_AMSW_IDLE);
+            PRINT_ERROR("Modem going to IDLE\n");
+            if	(l_RetCode != C_AMSW_ACK)
+                PRINT_ERROR("AMSW_ANT_requestModemStateChange(C_AMSW_IDLE) error!\n", l_RetCode);
+        } else {
+            g_ModemState = C_AMSW_IDLE;
+        }
+        AMSW_Modem_SW_Exit();
+}
